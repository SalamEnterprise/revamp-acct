## üß≠ 1Ô∏è‚É£ Pipeline Overview
| Layer                    | Tables                                     | Purpose                                      | Data Origin                     |
| ------------------------ | ------------------------------------------ | -------------------------------------------- | ------------------------------- |
| **Transactional Source** | `txn_source`                               | Raw business events (premium, claim, refund) | Operational system              |
| **Journal Staging**      | `je_header_staging`, `je_line_staging`     | Pre-posted journals (generated by Polars)    | Accounting engine               |
| **Journal Control**      | `je_batch_control`                         | Metadata for each posting batch              | Created when staging finishes   |
| **Ledger Core**          | `ledger_entry_header`, `ledger_entry_line` | Posted journals (immutable)                  | From staging after verification |
| **Ledger Balances**      | `account_balance_snapshot`                 | Aggregated balances per account/fund/period  | Derived from posted lines       |

---
### Data Flow (General)
```mermaid
flowchart LR
    A["1Ô∏è‚É£ txn_source<br/>(gross_amount and components)"] --> B["2Ô∏è‚É£ Template Routing<br/>(match product/channel/txn_type)"]
    B --> C["3Ô∏è‚É£ Expand Journal Lines<br/>evaluate amount_expr"]
    C --> D["4Ô∏è‚É£ Validate DR=CR (template_control)"]
    D --> E["5Ô∏è‚É£ Stage JE Header & Line<br/>(UNLOGGED staging tables)"]
    E --> F["6Ô∏è‚É£ Post to Ledger<br/>partitioned by month"]
    F --> G["7Ô∏è‚É£ Update Balances & MVs<br/>Trial Balance, Fund Statement"]

```
---
### Sequence Diagram
```mermaid
sequenceDiagram
    autonumber
    participant TXN as txn_source
    participant TMP as journal_template*
    participant APP as Backend Engine (Python + Polars)
    participant STG as je_*_staging
    participant LED as ledger_entry_*
    participant REP as Reporting Views

    TXN->>APP: ‚ë† Load new txn_source (premium/claim)
    APP->>TMP: ‚ë° Lookup template + match by product/channel/date
    TMP-->>APP: ‚ë¢ Return active lines and conditions
    APP->>APP: ‚ë£ Compute amount_expr (Polars)
    APP->>APP: ‚ë§ Validate DR=CR within tolerance
    APP->>STG: ‚ë• COPY headers + lines
    STG->>LED: ‚ë¶ Post to ledger partitions
    LED->>REP: ‚ëß Update balances and materialized views

```
---
### Operational Lifecyce
```mermaid
flowchart TD
    LOAD["‚ë† Load txn_source"]
    MATCH["‚ë° Match template + expand journals"]
    VALID["‚ë¢ Validate integrity (DR=CR)"]
    STAGE["‚ë£ Stage to je_header_staging / je_line_staging"]
    POST["‚ë§ Post to ledger partitions"]
    SNAP["‚ë• Update account_balance_snapshot"]
    ARCH["‚ë¶ Archive failed/QA runs"]
    PURGE["‚ëß Purge old partitions"]
    LOAD --> MATCH --> VALID --> STAGE --> POST --> SNAP --> ARCH --> PURGE

```
---
### ER Model
```mermaid
flowchart TD
    %% Core entities
    subgraph SOURCE["txn_source"]
        S[source_rowid<br/>txn_type<br/>product_code<br/>channel<br/>gross_amount<br/>components]
    end

    subgraph TEMPLATE["Journal Template Catalog"]
        T["template_code + version<br/>txn_type, status, effective/expiry"]
        TM["match_id<br/>product_code / channel (nullable)<br/>priority, condition_expr"]
        TL["line_no<br/>side, account_code, fund_code, amount_expr"]
    end

    subgraph STAGING["Staging Tables"]
        H[je_header_staging<br/>run_id, template_code/version, je_date]
        L[je_line_staging<br/>run_id, account_code, fund, side, amount]
    end

    subgraph LEDGER["Ledger"]
        LH[ledger_entry_header<br/>je_number, date, type, run_id]
        LL[ledger_entry_line<br/>account_code, fund, side, amount]
        BAL[account_balance_snapshot<br/>period_start, acct, fund, debit/credit/balance]
    end

    S --> H
    T --> TM
    T --> TL
    H --> L
    H --> LH
    L --> LL
    LH --> LL
    LL --> BAL

```
---
```mermaid
erDiagram
    %% ==========================
    %% SOURCE
    %% ==========================
    txn_source {
        varchar source_rowid PK
        varchar txn_type
        varchar policy_no
        varchar product_code
        varchar channel
        date bank_value_date
        numeric gross_amount
        numeric tabarru_amount
        numeric tanahud_amount
        numeric invest_amount
        numeric ujroh_amount
        numeric admin_amount
    }

    %% ==========================
    %% JOURNAL TEMPLATES
    %% ==========================
    journal_template {
        varchar template_code PK
        varchar template_version PK
        varchar title
        varchar txn_type
        varchar description_pattern
        varchar je_type
        date effective_date
        date expiry_date
        varchar status
        varchar created_by
        timestamp created_at
        varchar approved_by
        timestamp approved_at
    }

    journal_template_match {
        bigint match_id PK
        varchar template_code FK
        varchar template_version FK
        varchar product_code "nullable (wildcard)"
        varchar channel "nullable (wildcard)"
        numeric min_amount
        numeric max_amount
        text condition_expr
        int priority
    }

    journal_template_line {
        varchar template_code FK
        varchar template_version FK
        int line_no PK
        char side
        varchar account_code
        varchar fund_code
        text amount_expr
        int amount_round
        boolean is_active
    }

    journal_template_line_cond {
        varchar template_code FK
        varchar template_version FK
        int line_no FK
        varchar cond_name
        text cond_expr
    }

    journal_template_control {
        varchar template_code FK
        varchar template_version FK
        boolean require_balanced
        numeric tolerance_amount
        varchar balancing_mode
        varchar balancing_account
        varchar balancing_fund
    }

    %% ==========================
    %% STAGING AND LEDGER
    %% ==========================
    je_header_staging {
        bigint je_internal_id PK
        uuid run_id
        varchar template_code
        varchar template_version
        date je_date
        varchar description
    }

    je_line_staging {
        bigint id PK
        uuid run_id
        bigint je_internal_id FK
        varchar account_code
        varchar fund
        char side
        numeric amount
    }

    ledger_entry_header {
        bigint je_id PK
        varchar je_number
        date je_date
        varchar je_type
        varchar source_rowid
        varchar template_code
        varchar template_version
        uuid run_id
    }

    ledger_entry_line {
        bigint id PK
        bigint je_id FK
        int line_no
        varchar account_code
        varchar fund
        char side
        numeric amount
    }

    account_balance_snapshot {
        date period_start PK
        varchar account_code PK
        varchar fund PK
        numeric opening_balance
        numeric debit
        numeric credit
        numeric closing_balance
    }

    %% ==========================
    %% RELATIONSHIPS
    %% ==========================
    txn_source ||--o{ je_header_staging : produces
    journal_template ||--o{ journal_template_match : "routing rules"
    journal_template ||--o{ journal_template_line : "posting lines"
    journal_template_line ||--o{ journal_template_line_cond : "conditional lines"
    journal_template ||--|| journal_template_control : "balance control"
    je_header_staging ||--o{ je_line_staging : "1..n lines"
    je_header_staging ||--o{ ledger_entry_header : "posted to"
    je_line_staging ||--o{ ledger_entry_line : "posted to"
    ledger_entry_header ||--o{ ledger_entry_line : "1..n"
    ledger_entry_line ||--|| account_balance_snapshot : "rolls up into"

```

## üß± 2Ô∏è‚É£ Posting Process: Staging ‚Üí Ledger
### Step 1: Validation
* Ensure double-entry rule: total DR = total CR per je_internal_id.
* Ensure all accounts and funds exist in dimension tables.
* Lock posting batch via je_batch_control:
* run_id
* total_headers
* total_lines
* hash_checksum
* created_at, created_by
* Step 2: Posting
* Copy staged journals to permanent ledger tables:
* ledger_entry_header (PK = je_id, unique je_number)
* ledger_entry_line (FK = je_id)
* Append-only (no updates).
### Step 3: Balances Update
* Aggregate to account_balance_snapshot:
* Group by (account_code, fund_code, period)
* Compute opening_balance, debit, credit, closing_balance
### Step 4: Audit Trail Completion
* Mark je_header_staging and je_line_staging as posted = TRUE and store posted_at.
* Retain run_id linkage across all layers.

## üß≠ Structure Overview

| Layer                    | Tables                                         | Function                                                                                  |
| ------------------------ | ---------------------------------------------- | ----------------------------------------------------------------------------------------- |
| **Source (Business)**    | `txn_source`                                   | Raw operational transactions from upstream (policy admin, claims, billing)                |
| **Accounting (Staging)** | `je_header`, `je_line`                         | Generated journals ‚Äî each header summarizing one business event, each line a debit/credit |
| **Dimensions**           | `chart_of_accounts`, `fund_dim`, `product_dim` | Reference structures for reporting, validation, and financial statement mapping           |

## üß† 4Ô∏è‚É£ Data Lineage
| From                                             | To                                    | Key                               | Purpose |
| ------------------------------------------------ | ------------------------------------- | --------------------------------- | ------- |
| `txn_source` ‚Üí `je_header_staging`               | `source_rowid`                        | Trace transaction origin          |         |
| `je_header_staging` ‚Üí `ledger_entry_header`      | `je_number`, `run_id`                 | Transition from staging to posted |         |
| `je_line_staging` ‚Üí `ledger_entry_line`          | `je_internal_id` ‚Üí `je_id`            | Maintain line-level trace         |         |
| `ledger_entry_line` ‚Üí `account_balance_snapshot` | `account_code`, `fund_code`, `period` | Summarize financial position      |         |

## üß© 5Ô∏è‚É£ Posting Control Logic (conceptual)
| Phase                   | Action                              | Validation                  |
| ----------------------- | ----------------------------------- | --------------------------- |
| **Pre-check**           | Verify DR = CR                      | Reject if imbalance         |
| **Batch registration**  | Create entry in `je_batch_control`  | Store checksum              |
| **Posting**             | Insert into `ledger_entry_*` tables | Ensure unique `je_number`   |
| **Balance aggregation** | Update/insert snapshots             | Consistency by fund/account |
| **Finalize**            | Mark batch as POSTED                | Write `posted_at` timestamp |


## üßÆ Data Lineage Summary
| Trace Path                                              | Description                | Typical Use                     |
| ------------------------------------------------------- | -------------------------- | ------------------------------- |
| `txn_source.source_rowid ‚Üí je_header.source_rowid`      | Business ‚Üí Journal trace   | Transaction-to-accounting audit |
| `je_header.je_internal_id ‚Üí je_line.je_internal_id`     | Header ‚Üí Lines             | Ledger reconstruction           |
| `je_line.account_code ‚Üí chart_of_accounts.account_code` | Line ‚Üí Chart of Accounts   | Financial statement rollup      |
| `je_line.fund_code ‚Üí fund_dim.fund_code`                | Line ‚Üí Fund                | Takaful fund segregation        |
| `je_header.product_code ‚Üí product_dim.product_code`     | Header ‚Üí Product dimension | Product-level profitability     |

## üßæ Reporting Hierarchy (simplified)
### Trial Balance
```text
CHART_OF_ACCOUNTS
    ‚Üë
JE_LINE  ‚Üê  JE_HEADER  ‚Üê  TXN_SOURCE
```

### Fund Statement (Takaful)
```text
FUND_DIM
    ‚Üë
JE_LINE (fund movements)
```
### Product P&L
```text
PRODUCT_DIM
    ‚Üë
JE_HEADER + JE_LINE (aggregated by product_code)

```

```mermaid
flowchart LR
    %% SOURCE
    subgraph SOURCE["Source Transactions"]
        A["txn_source<br/>gross_amount = tabarru + tanahud + invest + ujroh + admin"]
    end

    %% BACKEND
    subgraph BACKEND["Backend Engine (Python + Polars)"]
        B1["1Ô∏è‚É£ Load txn_source from PostgreSQL"]
        B2["2Ô∏è‚É£ Match Journal Template<br/>(txn_type, product, channel, date, priority)"]
        B3["3Ô∏è‚É£ Expand Journal Lines<br/>Evaluate amount_expr using Polars"]
        B4["4Ô∏è‚É£ Validate Balance<br/>(require_balanced, tolerance)"]
    end

    %% STAGING
    subgraph STAGING["Database Staging (UNLOGGED)"]
        S1["je_header_staging"]
        S2["je_line_staging"]
    end

    %% LEDGER
    subgraph LEDGER["Official Ledger (Partitioned by Month)"]
        L1["ledger_entry_header"]
        L2["ledger_entry_line"]
        L3["account_balance_snapshot"]
    end

    %% REPORTING
    subgraph REPORT["Reporting & Analytics"]
        R1["Materialized Views<br/>Trial Balance / Fund / IFRS-17"]
    end

    %% FLOW
    A --> B1 --> B2 --> B3 --> B4 --> S1 & S2
    S1 & S2 --> LEDGER
    LEDGER --> R1

```

### üß† Audit Flow Example
#### Operational control
1. Trace a specific premium receipt:
  ```sql
  SELECT * FROM txn_source WHERE source_rowid='TXN-0001234';
SELECT * FROM je_header WHERE source_rowid='TXN-0001234';
SELECT * FROM je_line WHERE source_rowid='TXN-0001234';
```
#### Accounting reconstruction
   To rebuild the ledger for October 2025:
   ```sql
   SELECT account_code, SUM(CASE WHEN side='DR' THEN amount ELSE -amount END)
   FROM je_line
   WHERE je_date BETWEEN '2025-10-01' AND '2025-10-31'GROUP BY account_code;
   ```
#### Fund segregation
Verify Tabarru / Tanahud / Operator movements:
```sql
SELECT fund_code, SUM(amount) FROM je_line GROUP BY fund_code;

```

üßæ 6Ô∏è‚É£ Example Audit Queries

Find all JEs from one batch:
```sql
SELECT je_number, je_date FROM ledger_entry_header WHERE run_id = '...';
```

Trace back to transaction source:
```
SELECT t.*, h.je_number, h.run_id
FROM txn_source t
JOIN ledger_entry_header h ON t.source_rowid = h.source_rowid
WHERE h.je_number = '20251003-JEA-000000123';
```

Reconcile fund balances (Takaful view):
```sql
SELECT fund_code, SUM(CASE WHEN side='DR' THEN amount ELSE -amount END) AS net_movement
FROM ledger_entry_line
WHERE je_date BETWEEN '2025-10-01' AND '2025-10-31'
GROUP BY fund_code;
```

### Complete logical structure and audit trail relationships between txn_source, je_header, and je_line

### Operational Flow
```mermaid
sequenceDiagram
    autonumber
    participant TXN as Source<br/>(txn_source)
    participant APP as Backend Engine<br/>(Python + Polars)
    participant TMP as Template Catalog<br/>(journal_template*)
    participant STG as Staging Tables
    participant LED as Ledger Tables
    participant REP as Reporting Views

    TXN->>APP: ‚ë† Load new transactions<br/>(txn_type, gross_amount, components)
    APP->>TMP: ‚ë° Query journal_template + match<br/>by txn_type, product, channel
    TMP-->>APP: ‚ë¢ Return applicable template lines + conditions
    APP->>APP: ‚ë£ Evaluate amount_expr<br/>(Polars vectorized)
    APP->>APP: ‚ë§ Validate DR=CR within tolerance
    APP->>STG: ‚ë• COPY je_header_staging + je_line_staging
    STG->>LED: ‚ë¶ Post to ledger_entry_header / line<br/>(partition by month)
    LED->>REP: ‚ëß Update materialized views (trial balance, fund)

```

### Data flow diagram
```mermaid
flowchart TD
    %% =====================
    %% SOURCE LAYER
    %% =====================
    subgraph "1. Source System"
        A1[("txn_source<br>(raw transactions)<br>premium receipts, claims, etc.")]
    end

    %% =====================
    %% BACKEND ENGINE (Polars)
    %% =====================
    subgraph "2. Backend Application (Python + Polars)"
        B1["fund allocation + product/channel tagging<br>(vectorized in Polars)"]
        B2["journal expansion<br>(template lookup & DR/CR mapping)"]
        B3["validation<br>(balance check, account/fund existence, tolerance)"]
    end

    %% =====================
    %% STAGING LAYER
    %% =====================
    subgraph "3. Database Staging (PostgreSQL - UNLOGGED)"
        S1[("je_header_staging")]
        S2[("je_line_staging")]
        S3[("validation logs + batch control")]
    end

    %% =====================
    %% LEDGER
    %% =====================
    subgraph "4. Official Ledger (PostgreSQL - Partitioned)"
        L1[("ledger_entry_header<br>(immutable journal headers)")]
        L2[("ledger_entry_line<br>(partitioned by month je_date)")]
        L3[("account_balance_snapshot<br>(monthly roll-forward)")]
    end

    %% =====================
    %% REPORTING
    %% =====================
    subgraph "5. Reporting & Analytics"
        R1[("mv_trial_balance_month<br>(materialized view)")]
        R2[("v_product_channel_month<br>(view for P&L slice)")]
        R3[/"financial statements<br>Balance Sheet / P&L / Fund Statement"/]
    end

    %% =====================
    %% GOVERNANCE & AUDIT
    %% =====================
    subgraph "6. Governance & Audit Trail"
        G1["Batch Control (run_id, checksum, operator, status)"]
        G2["Reconciliation Dashboard"]
        G3["Data Lineage: source_rowid ‚Üî JE ‚Üî Ledger ‚Üî Report"]
    end

    %% =====================
    %% MAIN DATA FLOW
    %% =====================
    A1 ==>|load via COPY| B1
    B1 ==> B2
    B2 ==> B3
    B3 ==> S1 & S2 & S3
    
    S1 & S2 ==>|validation pass| L1 & L2
    L1 & L2 ==> L3
    
    L1 & L2 ==> R1 & R2
    R1 & R2 ==> R3

    %% =====================
    %% AUDIT FLOW
    %% =====================
    S1 & S2 & S3 -.-> G1
    S1 & S2 -.-> G2
    A1 -.-> G3
    S1 & S2 -.-> G3
    L1 & L2 -.-> G3
    R3 -.-> G3
```
### Template routing 
```mermaid
flowchart TB
    subgraph MATCH["Template Routing (journal_template_match)"]
        RQ["Inputs:<br/>txn_type, product_code, channel, date, gross_amount"]
        R1["Filter by txn_type, active period, status='ACTIVE'"]
        R2["Filter by (product_code = input OR NULL)"]
        R3["Filter by (channel = input OR NULL)"]
        R4["Filter by (gross_amount BETWEEN min_amount AND max_amount) OR NULL"]
        R5["Evaluate condition_expr (if any)"]
        R6["ORDER BY priority ASC, specific-first"]
        R7["LIMIT 1 ‚Üí selected template"]
    end
    RQ --> R1 --> R2 --> R3 --> R4 --> R5 --> R6 --> R7

```
### End-to-end operation lifecycle
```mermaid
flowchart TD
    LOAD["‚ë† Load txn_source via COPY"]
    VALIDATE["‚ë° Validate fund decomposition<br/>(gross = sum of components)"]
    EXPAND["‚ë¢ Expand to journals<br/>(via Polars templates)"]
    STAGE["‚ë£ Stage JE header & line"]
    POST["‚ë§ Post to ledger partitions"]
    BAL["‚ë• Update account_balance_snapshot"]
    ARCHIVE["‚ë¶ Archive failed/QA runs"]
    PURGE["‚ëß Purge old staging partitions"]
    LOAD --> VALIDATE --> EXPAND --> STAGE --> POST --> BAL --> ARCHIVE --> PURGE

```
### Staging live cycle 
```mermaid
flowchart TD
    %% ======================================================
    %% STAGING LIFECYCLE MANAGEMENT DIAGRAM
    %% ======================================================

    subgraph LOAD["‚ë† LOAD - Ingestion Stage"]
        A1["Source System<br/>(txn_source)"]
        A2["Backend Engine (Python + Polars)<br/>fund allocation + journal expansion"]
        A3["je_header_staging / je_line_staging<br/><b>UNLOGGED</b> PostgreSQL tables"]
        A1 -->|"COPY / bulk insert"| A2
        A2 -->|"COPY to staging"| A3
        noteA["
            Row volume: 1‚Äì8M<br/>
            Index: run_id, je_internal_id<br/>
            Frequency: hourly / daily
        "] 
        A3 -.-> noteA
    end

    subgraph VALIDATE["‚ë° VALIDATION - QA & Integrity"]
        V1["DR=CR check per JE"]
        V2["Account + fund existence check"]
        V3["Run metadata validation (batch_control)"]
        A3 --> V1 --> V2 --> V3
        noteV["
            Vectorized Polars validation<br/>
            <b>Time: ~3‚Äì5 sec</b><br/>
            Status updated: PENDING ‚Üí VALIDATED
        "]
        V3 -.-> noteV
    end

    subgraph POST["‚ë¢ POSTING - Move to Ledger"]
        P1["COPY ‚Üí ledger_entry_header / line<br/>partitioned by month"]
        P2["Update account_balance_snapshot<br/>and trial balance"]
        V3 -->|"Validated run_id only"| P1 --> P2
        noteP["
            <b>Time: ~60‚Äì70 sec</b><br/>
            8M lines posted<br/>
            Immutability enforced
        "]
        P2 -.-> noteP
    end

    subgraph ARCHIVE["‚ë£ ARCHIVE - Retain evidence"]
        R1["Insert failed runs into<br/>je_line_staging_archive"]
        R2["Insert headers into<br/>je_header_staging_archive"]
        P2 --> R1
        P2 --> R2
        noteR["
            Keeps audit trail<br/>
            <b>Retention: 30‚Äì90 days</b><br/>
            Optional compression (ZSTD)
        "]
        R2 -.-> noteR
    end

    subgraph PURGE["‚ë§ PURGE - Cleanup"]
        X1["DELETE or TRUNCATE<br/>old staging partitions"]
        X2["VACUUM / ANALYZE"]
        R2 --> X1 --> X2
        noteX["
            <b>Frequency:</b> weekly or monthly<br/>
            <b>Goal:</b> keep staging small & fast
        "]
        X2 -.-> noteX
    end

    %% DATAFLOW CONNECTIONS
    LOAD --> VALIDATE
    VALIDATE --> POST
    POST --> ARCHIVE
    ARCHIVE --> PURGE

    %% Styling (optional for better visuals in GitHub)
    classDef stage fill:#f0f7ff,stroke:#0366d6,stroke-width:2px,color:#000;
    class LOAD,VALIDATE,POST,ARCHIVE,PURGE stage
    classDef note fill:#fff3cd,stroke:#856404,stroke-dasharray: 5 5,color:#856404,font-size:12px;
    class noteA,noteV,noteP,noteR,noteX note
```

## SQL-based automatic partition rotation
```sql
-- parent
CREATE TABLE IF NOT EXISTS public.je_line_staging_parent
    (LIKE public.je_line_staging INCLUDING ALL)
    PARTITION BY RANGE (created_at);

-- procedure to rotate partitions
CREATE OR REPLACE PROCEDURE public.rotate_staging_partitions()
LANGUAGE plpgsql AS $$
DECLARE
    start_date DATE := date_trunc('month', current_date);
    next_date  DATE := start_date + interval '1 month';
    tbl_name   TEXT;
BEGIN
    tbl_name := format('je_line_staging_%s', to_char(start_date,'YYYYMM'));
    IF NOT EXISTS (
        SELECT 1 FROM pg_class WHERE relname = tbl_name
    ) THEN
        EXECUTE format(
          'CREATE UNLOGGED TABLE public.%I PARTITION OF public.je_line_staging_parent
           FOR VALUES FROM (%L) TO (%L)',
           tbl_name, start_date, next_date);
        RAISE NOTICE 'Created new staging partition: %', tbl_name;
    END IF;
END;
$$;

-- schedule monthly
CALL public.rotate_staging_partitions();

-- parent
CREATE TABLE IF NOT EXISTS public.je_line_staging_parent
    (LIKE public.je_line_staging INCLUDING ALL)
    PARTITION BY RANGE (created_at);

-- procedure to rotate partitions
CREATE OR REPLACE PROCEDURE public.rotate_staging_partitions()
LANGUAGE plpgsql AS $$
DECLARE
    start_date DATE := date_trunc('month', current_date);
    next_date  DATE := start_date + interval '1 month';
    tbl_name   TEXT;
BEGIN
    tbl_name := format('je_line_staging_%s', to_char(start_date,'YYYYMM'));
    IF NOT EXISTS (
        SELECT 1 FROM pg_class WHERE relname = tbl_name
    ) THEN
        EXECUTE format(
          'CREATE UNLOGGED TABLE public.%I PARTITION OF public.je_line_staging_parent
           FOR VALUES FROM (%L) TO (%L)',
           tbl_name, start_date, next_date);
        RAISE NOTICE 'Created new staging partition: %', tbl_name;
    END IF;
END;
$$;

-- schedule monthly
CALL public.rotate_staging_partitions();

CREATE OR REPLACE PROCEDURE public.purge_old_staging_partitions(retention_days INT DEFAULT 30)
LANGUAGE plpgsql AS $$
DECLARE
    cutoff DATE := current_date - retention_days;
    r RECORD;
BEGIN
    FOR r IN
        SELECT inhrelid::regclass AS part_table
        FROM pg_inherits
        WHERE inhparent = 'public.je_line_staging_parent'::regclass
    LOOP
        IF (r.part_table::text ~ 'je_line_staging_[0-9]{6}') THEN
            IF to_date(substring(r.part_table::text, '([0-9]{6})$'), 'YYYYMM') < date_trunc('month', cutoff)
            THEN
                EXECUTE format('DROP TABLE IF EXISTS %I CASCADE;', r.part_table);
                RAISE NOTICE 'Dropped old staging partition: %', r.part_table;
            END IF;
        END IF;
    END LOOP;
END;
$$;

-- run weekly
CALL public.purge_old_staging_partitions(30);

CREATE TABLE IF NOT EXISTS public.je_line_staging_archive
(LIKE public.je_line_staging INCLUDING ALL);

CREATE OR REPLACE PROCEDURE public.archive_failed_runs()
LANGUAGE plpgsql AS $$
BEGIN
    INSERT INTO public.je_line_staging_archive
    SELECT * FROM public.je_line_staging_parent s
     WHERE s.run_id IN (
        SELECT run_id FROM batch_control WHERE status IN ('FAILED','REVIEW')
     );
    RAISE NOTICE 'Archived failed runs to je_line_staging_archive';
END;
$$;

-- execute daily after validation
CALL public.archive_failed_runs();


```
```bash
0 0 * * * psql -d salam_accounting -c "CALL rotate_staging_partitions();"
30 0 * * 0 psql -d salam_accounting -c "CALL purge_old_staging_partitions(30);"
0 1 * * * psql -d salam_accounting -c "CALL post_batch(current_run_id());"

```
